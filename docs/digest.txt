Directory structure:
└── codesprout/
    ├── .pre-commit-config.yaml
    ├── docs/
    │   ├── PRD.md
    │   └── TASKS.md
    ├── src/
    │   ├── bundler.rs
    │   ├── main.rs
    │   └── parser.rs
    ├── tests/
    │   └── integration_tests.rs
    ├── .cursor/
    ├── .github/
    │   └── workflows/
    │       └── ci.yml
    └── .roo/

================================================
File: .pre-commit-config.yaml
================================================
repos:
  - repo: local
    hooks:
      - id: rustfmt-check
        name: rustfmt (check)
        entry: cargo fmt --all -- --check
        language: system
        types: [rust]
        pass_filenames: false
        verbose: true
      - id: clippy-check
        name: clippy (check)
        entry: cargo clippy --all-targets -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false
        verbose: true



================================================
File: docs/PRD.md
================================================
# codesprout - Product Requirements Document (Prototype)

## 1. Introduction

- **Project Idea:** `codesprout` is a project to develop a command-line interface (CLI) utility named `sprout`. The `sprout` tool's primary function is to parse a single, consolidated text file (referred to as a "bundle file," formatted like the provided `digest.txt` example) and "sprout" its contents into an organized directory structure with corresponding files.
- **Problem/Need:** Developers, educators, and technical writers often need to share or archive sets of code files or project snippets. Traditional methods like zip archives are not always convenient, especially for embedding into documents, wikis, or systems that primarily accept plain text. A single-file representation simplifies copy-pasting, sharing in restrictive environments, and creating self-contained examples.
- **Prototype Goal:** To build a functional `sprout` CLI in Rust that can reliably parse a `digest.txt`-style bundle file, validate its format, and recreate the described directory structure and files in a specified output location. The prototype must include clear error reporting for format issues and abort on any potential file collisions in the output directory.

## 2. Core Features / User Stories

- **Feature 1: Sprout from Bundle**
    - Description: The `sprout` CLI will read a specified bundle file (formatted like `digest.txt`), parse its content to identify individual files and their target paths, and then create these files and any necessary parent directories in the designated output location.
    - User Action(s): The user executes the `sprout` command, providing the path to the bundle file and an optional output directory.
    - Outcome(s):
        - If the bundle file is valid and no file collisions are detected in the output path, the specified directory structure and files are created as per the bundle file's content. A success message is displayed.
        - If the bundle file contains format errors, all errors are reported to the user, and no file system modifications are made.
        - If creating any file would overwrite an existing file or directory in the output path, the operation is aborted before any files are written, and an error message is displayed.
    - Command: `sprout`
    - Key Inputs:
        - Bundle File Path (required): Provided as a positional argument or via `-i <path>` / `--input <path>`.
        - Output Directory Path (optional): Provided as a positional argument or via `-o <path>` / `--output <path>`. Defaults to the current working directory.
    - Expected Output:
        - Console messages indicating files being processed (optional, perhaps under a verbose flag in the future, but basic status for prototype).
        - Clear success message upon completion.
        - Detailed error messages if bundle file validation fails or if file collisions are detected.
        - The recreated files and directories in the specified output location.

## 3. Technical Specifications

- **Primary Language(s):** Rust (latest stable version available at the time of development, e.g., 1.7X.X).
- **Key Frameworks/Libraries:**
    - `clap`: For parsing CLI arguments.
    - `anyhow`: (Recommended) For application-level error handling and reporting.
- **Database (if any):** None for this prototype.
- **Key APIs/Integrations (if any):** None.
- **Deployment Target (if applicable for prototype):** Local native executable for common desktop platforms (Linux, macOS, Windows).
- **High-Level Architectural Approach:**
    - A CLI application built in Rust.
    - Core logic will be separated into modules:
        - One module for parsing the `digest.txt`-style bundle file.
        - One module for handling file system operations (directory creation, file writing, collision detection).
        - Error handling will be centralized, potentially using custom error types or `anyhow` for context.
    - The process flow will be: 1. Parse arguments. 2. Read and fully validate the input bundle file. 3. Check for output collisions. 4. If all checks pass, create directories and files.
- **Critical Technical Decisions/Constraints:**
    - The input bundle file format is strictly the `digest.txt` style (multi-file concatenation with `================================================\nFile: path/to/file.ext\n================================================\n...content...` delimiters).
    - The `sprout` tool will perform a full analysis of the input bundle file for any format errors before attempting any file system modifications. If errors are found, they will be reported, and the tool will exit.
    - The tool will check for potential file/directory collisions in the target output directory before writing any files. If any collision is detected, the operation will be aborted with an error message, and no files will be written.

## 4. Project Structure (Optional)

A standard Rust binary (application) project structure will be used, generated initially by `cargo new sprout --bin`.

```
/codesprout_project_root
  ├── .git/
  ├── .github/              # For GitHub Actions, issue templates, etc.
  ├── docs/
  │   ├── PRD.md            # This document
  │   └── TASKS.md          # Task list
  ├── src/
  │   ├── main.rs           # CLI entry point, argument parsing (clap), main logic flow
  │   ├── parser.rs         # Module for parsing the bundle file
  │   ├── bundler.rs        # Module for file/directory creation and output logic (renamed from sprouter for clarity)
  │   └── error.rs          # (Optional) Module for custom error types if not solely relying on anyhow
  ├── Cargo.toml            # Rust project manifest, dependencies
  ├── Cargo.lock            # Generated lockfile
  ├── README.md             # Project README
  └── target/               # Build artifacts (ignored by git)
```

- `src/`: Contains all Rust source code.
    - `main.rs`: Handles CLI argument parsing using `clap` and orchestrates the overall process.
    - `parser.rs`: Responsible for reading and validating the `digest.txt`-style bundle file format.
    - `bundler.rs`: Handles the creation of directories and files based on the parsed bundle, including collision checks.
- `docs/`: Contains project documentation.
- `Cargo.toml`: Defines project metadata, dependencies (like `clap`, `anyhow`), and profiles (e.g., for release optimization).

## 5. File Descriptions (If applicable)

- **Input Bundle File (e.g., `my_bundle.txt`, `project.digest`)**:
    - Purpose: A single text file containing the content of multiple source files or text-based project structures, along with their intended relative paths.
    - Format: Plain text. Each embedded file is demarcated by a header `================================================\nFile: path/to/file.ext\n================================================\n` followed by its content. The `path/to/file.ext` specifies the relative path where the file should be created in the output directory.
    - Key Contents: A sequence of file path specifications and their corresponding multi-line text content.

## 6. Future Considerations / Out of Scope (for this prototype)

- **Out of Scope for Prototype:**
    - **Reverse Operation ("Bundling"):** Creating a bundle file from an existing directory structure.
    - **Advanced Overwrite Options:** No `--force` flag or interactive prompts to overwrite files. The prototype will only abort on collision.
    - **Configuration File:** No external configuration for `sprout` (e.g., to customize delimiters or behavior).
    - **Ignore Patterns:** No functionality to ignore specific files or patterns during a (future) bundling operation.
    - **Complex Format Validation Beyond Basic Structure:** While basic structural validation (presence of delimiters, parsable paths) is in scope, deep semantic analysis of the content within files is not.
    - **Watching files or live updates.**
- **Potential Future Enhancements (Post-Prototype):**
    - Implement the reverse "bundling" operation.
    - Add file overwrite protection options (`--force`, skip, prompt).
    - Introduce a configuration file for `sprout`.
    - Support for ignore patterns (like `.gitignore`) during bundling.
    - Stricter validation options for bundle files.
    - Support for different bundle formats or custom delimiters via configuration.

## 7. Project-Specific Coding Rules (Optional)

- **Language Version:** Rust (latest stable version at the time of development).
- **Formatting:** `rustfmt` is mandatory. Code should be formatted using `cargo fmt` before committing.
- **Linting:** `clippy` is mandatory. Code should pass `cargo clippy --all-targets -- -D warnings` (fail on warnings).
- **Error Handling:**
    - Use Rust's standard `Result<T, E>` for all functions that can produce an error.
    - Utilize the `?` operator for concise error propagation.
    - Employ the `anyhow` crate for creating and managing application-level errors, providing context, and simplifying error returns from `main()`.
- **Dependencies (`Cargo.toml`):**
    - `clap` will be used for CLI argument parsing.
    - `anyhow` will be used for error handling.
    - Other external crate dependencies should be minimized and require justification for inclusion in the prototype.
- **Testing:**
    - Unit tests for the `parser.rs` module to ensure correct parsing of various valid and invalid bundle file scenarios.
    - Unit tests for the `bundler.rs` module to ensure correct file/directory creation, path handling, and collision detection logic.
    - Integration-style tests (CLI tests) to verify the overall behavior of `sprout` with sample bundle files and output directory states.
- **Naming Conventions:** Adhere to standard Rust naming conventions:
    - `snake_case` for functions, methods, variables, and modules.
    - `PascalCase` (or `CamelCase`) for types, structs, enums, and traits.
    - `UPPER_SNAKE_CASE` for constants.
- **Binary Size:** Strive for a reasonably small binary size for the release executable by configuring the release profile in `Cargo.toml` (e.g., `opt-level = "z"`, `lto = true`, `codegen-units = 1`, `panic = "abort"`, `strip = true`) and/or using `strip` utility post-compilation.
- **Comments:** Write clear comments for complex logic, public API functions, and any non-obvious decisions. Doc comments (`///`) for public items are encouraged.
- **Modularity:** Keep functions small and focused. Modules should have clear responsibilities.



================================================
File: docs/TASKS.md
================================================
# codesprout - Task List

## Milestone 0: Development Environment & Workflow Setup

**Goal:** Establish a consistent Rust development environment using `mise` and define commands/scripts for essential development tasks such as formatting, linting, building, and testing the `sprout` CLI.

- [x] **Task 0.1: Setup `mise` for Rust Version Management**
  - [x] Create a `mise.toml` file in the project root.
  - [x] Specify the Rust version to be used for the project (e.g., `rust = "latest"` or a specific version like `rust = "1.87"` to align with PRD).
  - [x] Verification: After navigating to the project directory in a new terminal, `mise current rust` (or `mise which rustc`) shows the correct Rust compiler path and version as specified in `.mise.toml`. Running `rustc --version` confirms the active version.

- [x] **Task 0.2: Define Code Formatting Task & Integration**
  - [x] Document the command for checking formatting: `cargo fmt --all --check`.
  - [x] Document the command for applying formatting: `cargo fmt --all`.
  - [x] (Optional) Consider integrating `cargo fmt --all --check` into a pre-commit hook or CI step later.
    - [x] Verification: `cargo fmt --all --check` passes on a cleanly formatted codebase. `cargo fmt --all` correctly formats any misformatted Rust files.
- [x] **Task 0.3: Define Code Linting Task & Integration**
  - [x] Document the command for linting: `cargo clippy --all-targets -- -D warnings` (treat all warnings as errors).
  - [x] (Optional) Consider integrating this lint check into a pre-commit hook or CI step later.
  - [x] Verification: `cargo clippy --all-targets -- -D warnings` passes on a lint-free codebase.
- [ ] **Task 0.4: Define Building Tasks**
  - [x] Document command for debug builds: `cargo build`.
  - [ ] Document command for optimized release builds: `cargo build --release`.
  - [x] Note: `Cargo.toml` should be configured with release profile optimizations as per PRD (e.g., `opt-level = "z"`, `lto = true`, `panic = "abort"`, `strip = true`).
  - [x] Verification: `cargo build` successfully compiles the project. `cargo build --release` successfully compiles the project and produces an optimized binary.
- [x] **Task 0.5: Define Testing Task**  
    - [x] Document command for running all tests: `cargo test`.
    - [x] Document command for running tests with more output: `cargo test -- --nocapture` (if needed for debugging).
    - [x] Verification: `cargo test` runs all available tests and reports pass/fail status (initially, this might be an empty test suite or auto-generated tests).

## Milestone 1: Project Initialization & CLI Argument Parsing

**Goal:** Initialize the Rust project structure for `sprout` (if not fully covered by Milestone 0 tasks related to `cargo new`), implement robust command-line argument parsing using `clap`, and set up the basic application structure to handle the main processing flow.

- [x] **Task 1.1: Complete Rust Project Initialization**
    
    - [x] Run `cargo new sprout --bin` (if not done as part of `mise` setup or if a fresh start is preferred).
    - [x] Ensure `Cargo.toml` is correctly configured:
        - Set `name = "sprout"` (as the binary will be `sprout`), `description = "A CLI tool to sprout files from a bundle."`, `authors = ["Your Name <you@example.com>"]`, `edition = "2024"`, `version = "0.1.0"`.
        - Add `clap` as a dependency with the "derive" feature (e.g., `clap = { version = "4.x", features = ["derive"] }`).
        - Add `anyhow` as a dependency (e.g., `anyhow = "1.x"`).
    - [x] Verification: Project compiles successfully (`cargo build`). `Cargo.toml` reflects the specified settings and dependencies. `sprout --version` (once version is integrated with `clap`'s `App::version`) works.
- [x] **Task 1.2: Implement CLI Argument Parsing with `clap`**
    
    - [x] In `src/main.rs`, define a struct (e.g., `CliArgs`) using `clap::Parser` to manage command-line arguments.
    - [x] Implement parsing for:
        - `bundle_file_path` (positional, `PathBuf`, required unless `-i` is used).
        - `output_directory_path` (positional, `PathBuf`, optional, defaults to current directory unless `-o` is used).
        - `-i, --input <PATH>`: Optional flag for bundle file path (`Option<PathBuf>`).
        - `-o, --output <PATH>`: Optional flag for output directory path (`Option<PathBuf>`).
    - [x] Logic to determine effective input and output paths (handling defaults and overrides).
    - [x] Ensure input path is effectively mandatory.
    - [x] In `main()`, parse the arguments using `CliArgs::parse()`.
    - [x] Verification:
        - `sprout --help` displays correctly formatted help message with all arguments and options.
        - `sprout valid_bundle.txt` correctly identifies `valid_bundle.txt` as input and uses `.` as default output.
        - `sprout -i valid_bundle.txt -o ./my_output` correctly parses input and output paths.
        - `sprout ./my_output_dir` (assuming `my_output_dir` is not the bundle file) is handled by clap for positional args.
        - `sprout` (with no input arguments) shows an error message from `clap` indicating missing required input.
- [x] **Task 1.3: Establish Main Application Logic Flow & Error Handling**
    
    - [x] In `src/main.rs`, ensure `main` function returns `anyhow::Result<()>`.
    - [x] Define the high-level steps based on parsed arguments:
        1. Resolve final input and output paths.
        2. (Stub) Call `parser::process_bundle_file(input_path)`.
        3. (Stub) If parsing/validation successful, call `bundler::create_files(parsed_data, output_path)`.
    - [x] Implement basic stubs for these functions in their respective (future) modules (`parser.rs`, `bundler.rs`).
    - [x] Ensure `main` propagates errors from these calls using `?`.
    - [x] Verification: The `sprout` command runs, prints placeholder messages for each stubbed step based on parsed arguments, and exits gracefully (or with a placeholder error from a stub).

## Milestone 2: Bundle File Parsing and Validation

**Goal:** Implement the complete logic for reading, parsing, and validating the `digest.txt`-style bundle file. The tool should be able to identify all format errors in the bundle file before any file system operations are attempted.

- [x] **Task 2.1: Develop Bundle File Parser (`src/parser.rs`)**
    
    - [x] Create the `src/parser.rs` module. (Covered by previous tasks or implicitly by creating the file)
    - [x] Define a public function, e.g., `parse_bundle(bundle_path: &Path) -> anyhow::Result<Vec<ParsedEntry>>`.
    - [x] Implement logic to read the content of the bundle file.
    - [x] Implement parsing logic to iterate through the file content, recognizing the `================================================\nFile: path/to/file.ext\n================================================\n...content...` structure.
    - [x] Extract the relative file path (`String` or `PathBuf`) and the multi-line content (`String`) for each entry.
    - [x] Store the parsed data in a struct, e.g., `pub struct ParsedEntry { pub path: PathBuf, pub content: String }`.
    - [x] Verification: Unit tests for the `parser::parse_bundle` function covering:
        - [x] Empty bundle file (should return empty Vec or appropriate error).
        - [x] Bundle file with one entry.
        - [x] Bundle file with multiple entries.
        - [x] Entries with empty content.
        - [x] Entries with complex multi-line content.
        - [x] Correct path extraction (including paths with subdirectories).
- [x] **Task 2.2: Implement Bundle File Format Validation**
    
    - [x] Within `src/parser.rs`, enhance the parsing or add a distinct validation step for the parsed entries and the overall bundle structure. This validation should occur before returning successfully from `parse_bundle`.
    - [x] Validation checks should include:
        - Each `File:` header line must be properly formed and contain a non-empty, valid relative path.
        - No duplicate paths within the bundle.
        - Consider edge cases: premature EOF, missing headers, content before the first header (should it be ignored or an error?). (Implemented: content before first header is an error; other structural errors handled)
    - [x] The validation should collect _all_ format errors found in the bundle and return them as a single `anyhow::Error` (possibly by formatting a list of specific error details).
    - [x] In `src/main.rs`, call `parse_bundle`. If it returns `Err`, print the error (which should now include all validation issues) and exit. (Handled by `anyhow` and `?` operator).
    - [x] Verification:
        - Update unit tests for `parser::parse_bundle` to cover various invalid bundle file scenarios (e.g., malformed `File:` line, duplicate paths, EOF within a file block).
        - Test the `sprout` CLI with sample malformed bundle files; ensure all relevant errors are reported clearly and the program exits without attempting to write files.

## Milestone 3: File System Operations, Collision Detection, and Final Integration

**Goal:** Implement the logic to create the directory structure and files as specified in the parsed bundle. This includes robust collision detection in the output directory. This milestone will result in a fully functional `sprout` CLI for its core purpose.

- [x] **Task 3.1: Implement Output Path Collision Detection (`src/bundler.rs`)**
    
    - [x] Create the `src/bundler.rs` module.
    - [x] Implement a function, e.g., `check_for_collisions(entries: &[ParsedEntry], output_dir: &Path) -> anyhow::Result<()>`.
    - [x] For each `ParsedEntry` in the list:
        - Construct the full target path by joining `output_dir` and `entry.path`.
        - Check if this full target path already exists using `std::path::Path::exists()`.
    - [x] If any path collision is detected, this function should return an `anyhow::Error` detailing all collisions found.
    - [x] In `src/main.rs`, call this collision check function after successful bundle parsing. If it returns `Err`, print the error and exit.
    - [x] Verification:
        - Unit tests for `bundler::check_for_collisions` with scenarios: no collisions, one collision, multiple collisions, collision with a file where a directory is needed, collision with a directory where a file is needed.
        - CLI Test: `sprout` aborts with an informative error if a target file path already exists.
        - CLI Test: `sprout` aborts if a parent directory to be created (e.g., `new_dir/`) conflicts with an existing file named `new_dir`.
- [x] **Task 3.2: Implement Directory and File Creation (`src/bundler.rs`)**
    
    - [x] Implement a function, e.g., `create_files_from_bundle(entries: &[ParsedEntry], output_dir: &Path) -> anyhow::Result<()>`.
    - [x] This function is called only if bundle parsing and collision checks pass.
    - [x] For each `ParsedEntry`:
        - [x] Resolve the full absolute path for the new file.
        - [x] Ensure its parent directory exists using `std::fs::create_dir_all(parent_path)`.
        - [x] Write the `entry.content` to the file path using `std::fs::write`.
    - [x] Handle potential I/O errors during directory/file creation gracefully, returning an `anyhow::Error`.
    - [x] Verification:
        - [x] Unit tests for `bundler::create_files_from_bundle` to verify:
            - [x] Creation of a single file in the output directory.
            - [x] Creation of multiple files.
            - [x] Creation of files within newly created nested subdirectories.
            - [x] Correct writing of file content.
        - (Covered by integration tests in next task mostly)
- [x] **Task 3.3: Final Integration, User Feedback, and Testing**
    
    - [x] Integrate all components in `src/main.rs`: CLI parsing (`clap`), bundle file reading/validation (`parser.rs`), collision detection, and file/directory creation (`bundler.rs`).
    - [x] Implement clear success messages (e.g., "Successfully sprouted N files to <output_directory>.").
    - [x] Ensure all error paths (bundle format errors, I/O errors, collision errors) provide user-friendly messages propagated by `anyhow`.
    - [x] Write integration tests for the `sprout` CLI (e.g., using a test runner or simple shell scripts that invoke the compiled binary):
        - [x] Test with a valid bundle file creating a simple structure.
        - [x] Test with a valid bundle file creating a nested structure.
        - [x] Test failure with a malformed bundle file (ensure all errors are printed).
        - [x] Test failure due to output file collision (ensure specific collision is reported).
        - [x] Test with empty bundle file.
        - [x] Test output to current directory (default) and to a specified directory.
    - [x] Verification: The `sprout` command works end-to-end for valid scenarios and fails gracefully with correct, comprehensive error messages for all defined error conditions. Code coverage for core logic (parsing, bundling) is reasonable.

## Additional Tasks / Backlog

(Items from the PRD's "Future Considerations" that are out of scope for this initial prototype but good to keep in mind for future development)

- [ ] Implement Reverse Operation ("Bundling" a directory into a `digest.txt` style file).
- [ ] Add file overwrite protection options (`--force`, skip, prompt).
- [ ] Introduce a configuration file for `sprout` (e.g., custom delimiters, default output dir).
- [ ] Add more comprehensive test cases for file system edge cases (permissions, symlinks, etc.).
- [ ] Refine and add more detailed verbose logging options (e.g., using `log` and `env_logger` crates).
- [ ] Research and implement packaging/distribution methods for the Rust binary (e.g., `cargo-dist`, GitHub Releases assets, AUR, Homebrew).
- [ ] Performance benchmarking and optimization for very large bundle files or a high number of files.


================================================
File: src/bundler.rs
================================================
// src/bundler.rs
// Module for file/directory creation and output logic

use crate::parser::ParsedEntry;
use anyhow::{Context, Result};
use std::{
    fs,
    path::{Path, PathBuf},
};

/// Creates directories and files based on the parsed bundle entries.
///
/// This function is called only if bundle parsing and collision checks pass.
/// For each `ParsedEntry`:
///   - Resolves the full absolute path for the new file.
///   - Ensures its parent directory exists using `std::fs::create_dir_all(parent_path)`.
///   - Writes the `entry.content` to the file path using `std::fs::write`.
///
/// Handles potential I/O errors during directory/file creation gracefully, returning an `anyhow::Error`.
pub fn create_files_from_bundle(entries: &[ParsedEntry], output_dir: &Path) -> Result<()> {
    for entry in entries {
        let full_target_path = output_dir.join(&entry.path);

        if let Some(parent_path) = full_target_path.parent() {
            if !parent_path.exists() {
                fs::create_dir_all(parent_path).with_context(|| {
                    format!("Failed to create parent directory: {:?}", parent_path)
                })?;
            }
        }

        fs::write(&full_target_path, &entry.content)
            .with_context(|| format!("Failed to write file: {:?}", full_target_path))?;
    }
    Ok(())
}

/// Checks for path collisions in the output directory.
///
/// For each `ParsedEntry`, it constructs the full target path by joining
/// `output_dir` and `entry.path`. It then checks if this full target path
/// already exists. If any collisions are detected, it returns an `anyhow::Error`
/// detailing all collisions.
pub fn check_for_collisions(entries: &[ParsedEntry], output_dir: &Path) -> Result<()> {
    let mut collisions = Vec::new();

    for entry in entries {
        let target_path = output_dir.join(&entry.path);
        if target_path.exists() {
            collisions.push(target_path);
        } else {
            let mut current_check_path = PathBuf::new();
            for component in entry
                .path
                .parent()
                .unwrap_or_else(|| Path::new(""))
                .components()
            {
                current_check_path.push(component);
                let full_component_path = output_dir.join(&current_check_path);
                if full_component_path.is_file()
                    && entry
                        .path
                        .strip_prefix(&current_check_path)
                        .is_ok_and(|p| !p.as_os_str().is_empty())
                {
                    collisions.push(full_component_path);
                    break;
                }
            }
        }
    }

    if !collisions.is_empty() {
        let collision_details = collisions
            .iter()
            .map(|p| format!("  - {}", p.display()))
            .collect::<Vec<String>>()
            .join("\n");
        return Err(anyhow::anyhow!(
            "Output path collision detected. The following paths already exist or conflict with directory creation:\n{}",
            collision_details
        ));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::ParsedEntry;
    use std::fs::{self, File};
    use tempfile::tempdir;

    fn create_parsed_entry(path_str: &str, content_str: &str) -> ParsedEntry {
        ParsedEntry {
            path: PathBuf::from(path_str),
            content: String::from(content_str),
        }
    }

    #[test]
    fn test_check_for_collisions_no_collision() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        let entries = vec![
            create_parsed_entry("file1.txt", "content1"),
            create_parsed_entry("dir1/file2.txt", "content2"),
        ];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_ok());
    }

    #[test]
    fn test_check_for_collisions_single_file_collision() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        File::create(output_dir.join("file1.txt")).unwrap();

        let entries = vec![
            create_parsed_entry("file1.txt", "content1"),
            create_parsed_entry("file2.txt", "content2"),
        ];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_err());
        let error_message = result.err().unwrap().to_string();
        assert!(error_message.contains("Output path collision detected"));
        assert!(error_message.contains(&output_dir.join("file1.txt").display().to_string()));
    }

    #[test]
    fn test_check_for_collisions_multiple_file_collisions() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        File::create(output_dir.join("file1.txt")).unwrap();
        fs::create_dir_all(output_dir.join("dir1")).unwrap();
        File::create(output_dir.join("dir1/file2.txt")).unwrap();

        let entries = vec![
            create_parsed_entry("file1.txt", "c1"),
            create_parsed_entry("dir1/file2.txt", "c2"),
            create_parsed_entry("file3.txt", "c3"),
        ];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_err());
        let error_message = result.err().unwrap().to_string();
        assert!(error_message.contains(&output_dir.join("file1.txt").display().to_string()));
        assert!(error_message.contains(&output_dir.join("dir1/file2.txt").display().to_string()));
    }

    #[test]
    fn test_check_for_collisions_directory_as_file_collision() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        fs::create_dir_all(output_dir.join("item")).unwrap();

        let entries = vec![create_parsed_entry("item", "content")];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_err());
        let error_message = result.err().unwrap().to_string();
        assert!(error_message.contains(&output_dir.join("item").display().to_string()));
    }

    #[test]
    fn test_check_for_collisions_file_as_directory_collision() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        File::create(output_dir.join("item")).unwrap();

        let entries = vec![create_parsed_entry("item/another.txt", "content")];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_err());
        let error_message = result.err().unwrap().to_string();
        assert!(error_message.contains(&output_dir.join("item").display().to_string()));
        assert!(error_message.contains("conflict with directory creation"));
    }

    #[test]
    fn test_check_for_collisions_deep_file_as_directory_collision() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path();
        fs::create_dir_all(output_dir.join("level1")).unwrap();
        File::create(output_dir.join("level1/item")).unwrap();

        let entries = vec![create_parsed_entry("level1/item/another.txt", "content")];

        let result = check_for_collisions(&entries, output_dir);
        assert!(result.is_err());
        let error_message = result.err().unwrap().to_string();
        assert!(error_message.contains(&output_dir.join("level1/item").display().to_string()));
    }

    #[test]
    fn test_create_single_file() -> Result<()> {
        let dir = tempdir()?;
        let output_dir = dir.path();
        let entries = vec![create_parsed_entry("file1.txt", "Hello World")];

        create_files_from_bundle(&entries, output_dir)?;

        let file_path = output_dir.join("file1.txt");
        assert!(file_path.exists());
        assert_eq!(fs::read_to_string(file_path)?, "Hello World");
        Ok(())
    }

    #[test]
    fn test_create_multiple_files() -> Result<()> {
        let dir = tempdir()?;
        let output_dir = dir.path();
        let entries = vec![
            create_parsed_entry("file1.txt", "Content 1"),
            create_parsed_entry("file2.txt", "Content 2"),
        ];

        create_files_from_bundle(&entries, output_dir)?;

        let file_path1 = output_dir.join("file1.txt");
        assert!(file_path1.exists());
        assert_eq!(fs::read_to_string(file_path1)?, "Content 1");

        let file_path2 = output_dir.join("file2.txt");
        assert!(file_path2.exists());
        assert_eq!(fs::read_to_string(file_path2)?, "Content 2");
        Ok(())
    }

    #[test]
    fn test_create_files_in_nested_directories() -> Result<()> {
        let dir = tempdir()?;
        let output_dir = dir.path();
        let entries = vec![
            create_parsed_entry("dir1/file1.txt", "Nested Content 1"),
            create_parsed_entry("dir1/dir2/file2.txt", "Deeply Nested Content 2"),
            create_parsed_entry("file3.txt", "Root Content 3"),
        ];

        create_files_from_bundle(&entries, output_dir)?;

        let path1 = output_dir.join("dir1/file1.txt");
        assert!(path1.exists());
        assert_eq!(fs::read_to_string(path1)?, "Nested Content 1");
        assert!(output_dir.join("dir1").is_dir());

        let path2 = output_dir.join("dir1/dir2/file2.txt");
        assert!(path2.exists());
        assert_eq!(fs::read_to_string(path2)?, "Deeply Nested Content 2");
        assert!(output_dir.join("dir1/dir2").is_dir());

        let path3 = output_dir.join("file3.txt");
        assert!(path3.exists());
        assert_eq!(fs::read_to_string(path3)?, "Root Content 3");
        Ok(())
    }

    #[test]
    fn test_create_file_with_empty_content() -> Result<()> {
        let dir = tempdir()?;
        let output_dir = dir.path();
        let entries = vec![create_parsed_entry("empty.txt", "")];

        create_files_from_bundle(&entries, output_dir)?;

        let file_path = output_dir.join("empty.txt");
        assert!(file_path.exists());
        assert_eq!(fs::read_to_string(file_path)?, "");
        Ok(())
    }

    #[test]
    fn test_create_files_complex_paths_and_content() -> Result<()> {
        let dir = tempdir()?;
        let output_dir = dir.path();
        let entries = vec![
            create_parsed_entry("src/main.rs", "fn main() {\n    println!(\"Hello\");\n}"),
            create_parsed_entry("docs/README.md", "# My Project\n\nThis is a test."),
            create_parsed_entry("config/settings.toml", "key = \"value\"\nnumber = 123"),
        ];

        create_files_from_bundle(&entries, output_dir)?;

        let path_rs = output_dir.join("src/main.rs");
        assert!(path_rs.exists());
        assert_eq!(
            fs::read_to_string(path_rs)?,
            "fn main() {\n    println!(\"Hello\");\n}"
        );
        assert!(output_dir.join("src").is_dir());

        let path_md = output_dir.join("docs/README.md");
        assert!(path_md.exists());
        assert_eq!(
            fs::read_to_string(path_md)?,
            "# My Project\n\nThis is a test."
        );
        assert!(output_dir.join("docs").is_dir());

        let path_toml = output_dir.join("config/settings.toml");
        assert!(path_toml.exists());
        assert_eq!(
            fs::read_to_string(path_toml)?,
            "key = \"value\"\nnumber = 123"
        );
        assert!(output_dir.join("config").is_dir());

        Ok(())
    }
}



================================================
File: src/main.rs
================================================
use clap::Parser;
use std::path::PathBuf;

mod bundler;
mod parser;

/// sprout - A CLI tool to sprout files from a bundle.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None, infer_long_args = true)]
struct CliArgs {
    /// Path to the bundle file (positional).
    /// Required unless -i/--input is used.
    #[arg(name = "BUNDLE_FILE_PATH", required_unless_present = "input")]
    bundle_file_path: Option<PathBuf>,

    /// Output directory path (positional).
    /// Defaults to the current directory if not specified and -o/--output is not used.
    #[arg(name = "OUTPUT_DIRECTORY_PATH", default_value = ".")]
    output_directory_path: PathBuf,

    /// Specify bundle file path via flag (alternative to positional BUNDLE_FILE_PATH).
    #[arg(short, long, value_name = "PATH", conflicts_with = "BUNDLE_FILE_PATH")]
    input: Option<PathBuf>,

    /// Specify output directory path via flag (overrides positional OUTPUT_DIRECTORY_PATH).
    #[arg(short, long, value_name = "PATH")]
    output: Option<PathBuf>,
}

fn main() -> anyhow::Result<()> {
    let args = CliArgs::parse();

    let bundle_path = match (args.bundle_file_path, args.input) {
        (Some(p), None) => p,
        (None, Some(i)) => i,
        _ => unreachable!("Clap should ensure one input source is exclusively provided and valid."),
    };

    let final_output_path = if let Some(output_flag_path) = args.output {
        output_flag_path
    } else {
        args.output_directory_path
    };

    let parsed_data = parser::parse_bundle(&bundle_path)?;

    if parsed_data.is_empty() {
        println!(
            "Bundle file '{}' is empty or contains no valid entries. Nothing to sprout.",
            bundle_path.display()
        );
        return Ok(());
    }

    bundler::check_for_collisions(&parsed_data, &final_output_path)?;

    bundler::create_files_from_bundle(&parsed_data, &final_output_path)?;

    println!(
        "Successfully sprouted {} file(s) from '{}' to '{}'.",
        parsed_data.len(),
        bundle_path.display(),
        final_output_path.display()
    );
    Ok(())
}



================================================
File: src/parser.rs
================================================
// src/parser.rs
// Module for parsing the bundle file

use anyhow::{Context, Result, anyhow};
use std::collections::HashSet;
use std::fmt;
use std::fs;
use std::path::{Path, PathBuf};

const FILE_HEADER_SEPARATOR: &str = "================================================";
const FILE_PATH_PREFIX: &str = "File: ";

/// Represents a single parsed file entry from the bundle.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParsedEntry {
    pub path: PathBuf,
    pub content: String,
}

/// Specific errors that can occur during bundle parsing and validation.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BundleValidationError {
    ContentBeforeFirstHeader {
        line_number: usize,
        content_excerpt: String,
    },
    MalformedHeaderMissingFilePrefix {
        line_number: usize,
        header_line: String,
    },
    MalformedHeaderMissingSeparatorAfterPath {
        line_number: usize,
        path_line: String,
    },
    MalformedHeaderPathLineInterruptedBySeparator {
        line_number: usize,
        path_line: String,
    },
    MalformedHeaderPathLineMissingNewline {
        line_number: usize,
        path_line: String,
    },
    MalformedHeaderMissingNewlineAfterContentSeparator {
        line_number: usize,
        separator_line: String,
    },
    EmptyPath {
        line_number: usize,
    },
    AbsolutePathNotAllowed {
        line_number: usize,
        path: String,
    },
    DuplicatePath {
        line_number: usize,
        path: String,
    },
    PrematureEOFBeforePathLine {
        line_number: usize,
    },
    PrematureEOFBeforeContentSeparator {
        line_number: usize,
        path: String,
    },
    PrematureEOFBeforeContentSeparatorNewline {
        line_number: usize,
        path: String,
    },
    UnexpectedContentAfterLastEntry {
        line_number: usize,
        content_excerpt: String,
    },
}

impl fmt::Display for BundleValidationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BundleValidationError::ContentBeforeFirstHeader {
                line_number,
                content_excerpt,
            } => write!(
                f,
                "L{}: Content found before the first file header. Starts with: \"{}\"",
                line_number, content_excerpt
            ),
            BundleValidationError::MalformedHeaderMissingFilePrefix {
                line_number,
                header_line,
            } => write!(
                f,
                "L{}: Malformed file header. Expected '{}' after separator line, found: \"{}\"",
                line_number, FILE_PATH_PREFIX, header_line
            ),
            BundleValidationError::MalformedHeaderMissingSeparatorAfterPath {
                line_number,
                path_line,
            } => write!(
                f,
                "L{}: Malformed file header. Expected separator line after path line, found: \"{}\"",
                line_number, path_line
            ),
            BundleValidationError::MalformedHeaderPathLineInterruptedBySeparator {
                line_number,
                path_line,
            } => write!(
                f,
                "L{}: Malformed file header. File path line is interrupted by a separator: \"{}\"",
                line_number, path_line
            ),
            BundleValidationError::MalformedHeaderPathLineMissingNewline {
                line_number,
                path_line,
            } => write!(
                f,
                "L{}: Malformed file header. File path line does not end with a newline: \"{}\"",
                line_number, path_line
            ),
            BundleValidationError::MalformedHeaderMissingNewlineAfterContentSeparator {
                line_number,
                separator_line,
            } => write!(
                f,
                "L{}: Malformed file header. Expected newline after content separator line: \"{}\"",
                line_number, separator_line
            ),
            BundleValidationError::EmptyPath { line_number } => {
                write!(f, "L{}: File path is empty.", line_number)
            }
            BundleValidationError::AbsolutePathNotAllowed { line_number, path } => write!(
                f,
                "L{}: Absolute path not allowed: \"{}\"",
                line_number, path
            ),
            BundleValidationError::DuplicatePath { line_number, path } => {
                write!(f, "L{}: Duplicate path found: \"{}\"", line_number, path)
            }
            BundleValidationError::PrematureEOFBeforePathLine { line_number } => write!(
                f,
                "L{}: Premature EOF. Expected 'File: <path>' line after separator.",
                line_number
            ),
            BundleValidationError::PrematureEOFBeforeContentSeparator { line_number, path } => {
                write!(
                    f,
                    "L{}: Premature EOF for file \"{}\". Expected second separator line after path.",
                    path, line_number
                )
            }
            BundleValidationError::PrematureEOFBeforeContentSeparatorNewline {
                line_number,
                path,
            } => write!(
                f,
                "L{}: Premature EOF for file \"{}\". Expected newline after content separator.",
                path, line_number
            ),
            BundleValidationError::UnexpectedContentAfterLastEntry {
                line_number,
                content_excerpt,
            } => write!(
                f,
                "L{}: Unexpected content found after the last valid file entry. Starts with: \"{}\"",
                line_number, content_excerpt
            ),
        }
    }
}

/// Container for multiple validation errors.
#[derive(Debug)]
pub struct BundleParseError {
    pub errors: Vec<BundleValidationError>,
}

impl fmt::Display for BundleParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "Bundle parsing failed with {} error(s):",
            self.errors.len()
        )?;
        for error in &self.errors {
            writeln!(f, "- {}", error)?;
        }
        Ok(())
    }
}

impl std::error::Error for BundleParseError {}

/// Parses a bundle file, extracting file paths and their content, and validating the format.
///
/// Collects all format errors found in the bundle.
pub fn parse_bundle(bundle_path: &Path) -> Result<Vec<ParsedEntry>> {
    let bundle_content = fs::read_to_string(bundle_path)
        .with_context(|| format!("Failed to read bundle file: {:?}", bundle_path))?;

    if bundle_content.trim().is_empty() {
        return Ok(Vec::new());
    }

    let mut entries = Vec::new();
    let mut validation_errors = Vec::new();
    let mut paths_seen = HashSet::new();

    let lines: Vec<&str> = bundle_content.lines().collect();

    let mut first_header_line_idx: Option<usize> = None;
    for (idx, line_content) in lines.iter().enumerate() {
        if line_content.trim_start().starts_with(FILE_HEADER_SEPARATOR)
            && idx + 1 < lines.len()
            && lines[idx + 1].trim_start().starts_with(FILE_PATH_PREFIX)
        {
            first_header_line_idx = Some(idx);
            break;
        }
    }

    let mut start_processing_from_line_idx = 0;
    let mut skipped_pre_header_line_numbers: Vec<usize> = Vec::new();

    if let Some(fh_idx) = first_header_line_idx {
        for (line_idx, line_content) in lines.iter().enumerate().take(fh_idx) {
            if !line_content.trim().is_empty() {
                skipped_pre_header_line_numbers.push(line_idx + 1);
            }
        }

        if !skipped_pre_header_line_numbers.is_empty() {
            let min_line = *skipped_pre_header_line_numbers.iter().min().unwrap();
            let max_line = *skipped_pre_header_line_numbers.iter().max().unwrap();
            if min_line == max_line {
                eprintln!(
                    "Warning: Line {} excluded due to content before the first file header.",
                    min_line
                );
            } else {
                eprintln!(
                    "Warning: Lines {}-{} excluded due to content before the first file header.",
                    min_line, max_line
                );
            }
        }
        start_processing_from_line_idx = fh_idx;
    } else if !bundle_content.trim().is_empty() {
        let first_actual_content_line_str = lines
            .iter()
            .find(|line| !line.trim().is_empty())
            .map_or("", |line| line.trim());

        validation_errors.push(BundleValidationError::ContentBeforeFirstHeader {
            line_number: 1,
            content_excerpt: first_actual_content_line_str.chars().take(50).collect(),
        });
    }

    let mut current_bundle_offset = 0;
    for line_content_str in lines.iter().take(start_processing_from_line_idx) {
        current_bundle_offset += line_content_str.len() + 1;
    }

    while current_bundle_offset < bundle_content.len() {
        let remaining_content = &bundle_content[current_bundle_offset..];
        let search_start_line = bundle_content[..current_bundle_offset].lines().count();

        match remaining_content.find(FILE_HEADER_SEPARATOR) {
            Some(header_relative_start) => {
                let header_absolute_start = current_bundle_offset + header_relative_start;
                let header_line_number =
                    bundle_content[..header_absolute_start].lines().count() + 1;

                let skipped_content = &bundle_content[current_bundle_offset..header_absolute_start];
                if !skipped_content.trim().is_empty() {
                    validation_errors.push(
                        BundleValidationError::UnexpectedContentAfterLastEntry {
                            line_number: search_start_line,
                            content_excerpt: skipped_content
                                .trim()
                                .lines()
                                .next()
                                .unwrap_or("")
                                .chars()
                                .take(50)
                                .collect(),
                        },
                    );
                }

                let current_separator_line_num = header_line_number;

                let after_first_sep_start = header_absolute_start + FILE_HEADER_SEPARATOR.len();
                if after_first_sep_start >= bundle_content.len() {
                    validation_errors.push(BundleValidationError::PrematureEOFBeforePathLine {
                        line_number: current_separator_line_num,
                    });
                    current_bundle_offset = bundle_content.len();
                    continue;
                }
                if bundle_content.as_bytes()[after_first_sep_start] != b'\n' {
                    validation_errors.push(
                        BundleValidationError::MalformedHeaderMissingFilePrefix {
                            line_number: current_separator_line_num + 1,
                            header_line: bundle_content[after_first_sep_start..]
                                .lines()
                                .next()
                                .unwrap_or("")
                                .trim_end()
                                .to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }
                let path_line_num = current_separator_line_num + 1;

                let path_line_start = after_first_sep_start + 1;
                if path_line_start >= bundle_content.len() {
                    validation_errors.push(BundleValidationError::PrematureEOFBeforePathLine {
                        line_number: path_line_num,
                    });
                    current_bundle_offset = bundle_content.len();
                    continue;
                }
                if !bundle_content[path_line_start..].starts_with(FILE_PATH_PREFIX) {
                    validation_errors.push(
                        BundleValidationError::MalformedHeaderMissingFilePrefix {
                            line_number: path_line_num,
                            header_line: bundle_content[path_line_start..]
                                .lines()
                                .next()
                                .unwrap_or("")
                                .to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }

                let path_actual_start = path_line_start + FILE_PATH_PREFIX.len();
                let path_line_terminator_search_slice = &bundle_content[path_actual_start..];
                let newline_pos_in_slice = path_line_terminator_search_slice.find('\n');

                let path_str_end_offset = match newline_pos_in_slice {
                    Some(nl_idx) => {
                        if path_line_terminator_search_slice[..nl_idx]
                            .contains(FILE_HEADER_SEPARATOR)
                        {
                            validation_errors.push(BundleValidationError::MalformedHeaderPathLineInterruptedBySeparator {
                                line_number: path_line_num,
                                path_line: bundle_content[path_actual_start .. path_actual_start + nl_idx].trim_end().to_string(),
                            });
                            current_bundle_offset = bundle_content.len();
                            continue;
                        }
                        path_actual_start + nl_idx
                    }
                    None => {
                        validation_errors.push(
                            BundleValidationError::MalformedHeaderPathLineMissingNewline {
                                line_number: path_line_num,
                                path_line: path_line_terminator_search_slice
                                    .lines()
                                    .next()
                                    .unwrap_or("")
                                    .trim_end()
                                    .to_string(),
                            },
                        );
                        current_bundle_offset = bundle_content.len();
                        continue;
                    }
                };

                let file_path_str = bundle_content[path_actual_start..path_str_end_offset].trim();
                if file_path_str.is_empty() {
                    validation_errors.push(BundleValidationError::EmptyPath {
                        line_number: path_line_num,
                    });
                }

                let path = PathBuf::from(file_path_str);
                if path.is_absolute() {
                    validation_errors.push(BundleValidationError::AbsolutePathNotAllowed {
                        line_number: path_line_num,
                        path: file_path_str.to_string(),
                    });
                }
                if !file_path_str.is_empty()
                    && !path.is_absolute()
                    && !paths_seen.insert(path.clone())
                {
                    validation_errors.push(BundleValidationError::DuplicatePath {
                        line_number: path_line_num,
                        path: file_path_str.to_string(),
                    });
                }
                let second_sep_line_num = path_line_num + 1;

                let second_sep_start = path_str_end_offset + 1;
                if second_sep_start >= bundle_content.len() {
                    validation_errors.push(
                        BundleValidationError::PrematureEOFBeforeContentSeparator {
                            line_number: second_sep_line_num,
                            path: file_path_str.to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }
                if !bundle_content[second_sep_start..].starts_with(FILE_HEADER_SEPARATOR) {
                    validation_errors.push(
                        BundleValidationError::MalformedHeaderMissingSeparatorAfterPath {
                            line_number: second_sep_line_num,
                            path_line: file_path_str.to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }

                let after_second_sep_start = second_sep_start + FILE_HEADER_SEPARATOR.len();
                if after_second_sep_start >= bundle_content.len() {
                    validation_errors.push(
                        BundleValidationError::PrematureEOFBeforeContentSeparatorNewline {
                            line_number: second_sep_line_num,
                            path: file_path_str.to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }
                if bundle_content.as_bytes()[after_second_sep_start] != b'\n' {
                    validation_errors.push(
                        BundleValidationError::MalformedHeaderMissingNewlineAfterContentSeparator {
                            line_number: second_sep_line_num,
                            separator_line: bundle_content[second_sep_start
                                ..std::cmp::min(
                                    bundle_content.len(),
                                    second_sep_start + FILE_HEADER_SEPARATOR.len(),
                                )]
                                .trim_end()
                                .to_string(),
                        },
                    );
                    current_bundle_offset = bundle_content.len();
                    continue;
                }

                let content_actual_start = after_second_sep_start + 1;

                let next_entry_header_search_start = content_actual_start;
                let content_end_offset = bundle_content[next_entry_header_search_start..]
                    .find(FILE_HEADER_SEPARATOR)
                    .map(|pos| next_entry_header_search_start + pos)
                    .unwrap_or_else(|| bundle_content.len());

                let content = bundle_content[content_actual_start..content_end_offset].to_string();

                if !file_path_str.is_empty() && !path.is_absolute() {
                    entries.push(ParsedEntry { path, content });
                }

                current_bundle_offset = content_end_offset;
            }
            None => {
                let final_remaining_content = &bundle_content[current_bundle_offset..];
                if !final_remaining_content.trim().is_empty() && !entries.is_empty() {
                    validation_errors.push(
                        BundleValidationError::UnexpectedContentAfterLastEntry {
                            line_number: bundle_content[..current_bundle_offset].lines().count()
                                + 1,
                            content_excerpt: final_remaining_content
                                .trim()
                                .lines()
                                .next()
                                .unwrap_or("")
                                .chars()
                                .take(50)
                                .collect(),
                        },
                    );
                }
                current_bundle_offset = bundle_content.len();
            }
        }
    }

    if !validation_errors.is_empty() {
        return Err(anyhow!(BundleParseError {
            errors: validation_errors
        }));
    }

    Ok(entries)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn create_temp_bundle_file(content: &str) -> NamedTempFile {
        let mut temp_file = NamedTempFile::new().expect("Failed to create temp file");
        write!(temp_file, "{}", content).expect("Failed to write to temp file");
        temp_file
    }

    fn assert_specific_error(
        result: &Result<Vec<ParsedEntry>, anyhow::Error>,
        expected_error: BundleValidationError,
    ) {
        match result {
            Err(err) => {
                if let Some(bundle_parse_error) = err.downcast_ref::<BundleParseError>() {
                    assert!(
                        bundle_parse_error.errors.contains(&expected_error),
                        "Expected error {:?} not found in {:?}",
                        expected_error,
                        bundle_parse_error.errors
                    );
                } else {
                    panic!("Error is not a BundleParseError: {:?}", err);
                }
            }
            Ok(_) => panic!("Expected error, but got Ok"),
        }
    }

    #[test]
    fn test_parse_empty_bundle_file() {
        let temp_file = create_temp_bundle_file("");
        let entries = parse_bundle(temp_file.path()).unwrap();
        assert!(entries.is_empty());
    }

    #[test]
    fn test_parse_bundle_file_with_only_whitespace() {
        let temp_file = create_temp_bundle_file("   \n\t  \n");
        let entries = parse_bundle(temp_file.path()).unwrap();
        assert!(entries.is_empty());
    }

    #[test]
    fn test_error_content_before_first_header() {
        let bundle_content = format!(
            "Some introductory text.\n\
            {}\n\
            {}path/to/file1.txt\n\
            {}\n\
            Content of file1.",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert!(result.is_ok(), "Expected Ok, got {:?}", result);
        let entries = result.unwrap();
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].path, PathBuf::from("path/to/file1.txt"));
        assert_eq!(entries[0].content, "Content of file1.");
    }

    #[test]
    fn test_error_content_before_first_header_no_valid_header_at_all() {
        let temp_file =
            create_temp_bundle_file("This is just some text, no valid file entries at all.");
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::ContentBeforeFirstHeader {
                line_number: 1,
                content_excerpt: "This is just some text, no valid file entries at a".to_string(),
            },
        );
    }

    #[test]
    fn test_parse_single_entry() {
        let bundle_content = format!(
            "{}\n\
            {}file.txt\n\
            {}\n\
            Hello, world!",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let entries = parse_bundle(temp_file.path()).unwrap();
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].path, PathBuf::from("file.txt"));
        assert_eq!(entries[0].content, "Hello, world!");
    }

    #[test]
    fn test_parse_multiple_entries() {
        let bundle_content = format!(
            "{}\n\
            {}file1.txt\n\
            {}\n\
            Content of file1.\n\
            {}\n\
            {}path/to/file2.rs\n\
            {}\n\
            // Rust code\nfn main() {{}}\n\
            {}\n\
            {}another.md\n\
            {}\n\
            ## Markdown Content",
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR,
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR,
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let entries = parse_bundle(temp_file.path()).unwrap();
        assert_eq!(entries.len(), 3);

        assert_eq!(entries[0].path, PathBuf::from("file1.txt"));
        assert_eq!(entries[0].content, "Content of file1.\n");

        assert_eq!(entries[1].path, PathBuf::from("path/to/file2.rs"));
        assert_eq!(entries[1].content, "// Rust code\nfn main() {}\n");

        assert_eq!(entries[2].path, PathBuf::from("another.md"));
        assert_eq!(entries[2].content, "## Markdown Content");
    }

    #[test]
    fn test_parse_entry_with_empty_content() {
        let bundle_content = format!(
            "{}\n\
            {}empty_file.txt\n\
            {}\n",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let entries = parse_bundle(temp_file.path()).unwrap();
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].path, PathBuf::from("empty_file.txt"));
        assert_eq!(entries[0].content, "");
    }

    #[test]
    fn test_error_malformed_header_missing_file_prefix() {
        let bundle_content = format!(
            "{}\n\
            Not File: path/to/file.txt\n\
            {}\n\
            Content",
            FILE_HEADER_SEPARATOR, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderMissingFilePrefix {
                line_number: 2,
                header_line: "Not File: path/to/file.txt".to_string(),
            },
        );
    }

    #[test]
    fn test_error_malformed_header_missing_separator_after_path() {
        let bundle_content = format!(
            "{}\n\
            {}path/to/file.txt\n\
            Content without second separator",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderMissingSeparatorAfterPath {
                line_number: 3,
                path_line: "path/to/file.txt".to_string(),
            },
        );
    }

    #[test]
    fn test_error_path_line_interrupted_by_separator() {
        let bundle_content = format!(
            "{}\n\
            {}path/to{}file.txt\n\
            {}\n\
            Content",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderPathLineInterruptedBySeparator {
                line_number: 2,
                path_line: format!("path/to{}file.txt", FILE_HEADER_SEPARATOR),
            },
        );
    }

    #[test]
    fn test_error_path_line_missing_newline() {
        let bundle_content = format!(
            "{}\n\
            {}path/to/file.txt",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderPathLineMissingNewline {
                line_number: 2,
                path_line: "path/to/file.txt".to_string(),
            },
        );
    }

    #[test]
    fn test_error_missing_newline_after_content_separator() {
        let bundle_content = format!(
            "{}\n\
            {}file.txt\n\
            {}{}",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR, "NoNewlineContent"
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderMissingNewlineAfterContentSeparator {
                line_number: 3,
                separator_line: FILE_HEADER_SEPARATOR.to_string(),
            },
        );
    }

    #[test]
    fn test_error_empty_path() {
        let bundle_content = format!(
            "{}\n\
            {}\n\
            {}\n\
            Content",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(&result, BundleValidationError::EmptyPath { line_number: 2 });
    }

    #[test]
    fn test_error_absolute_path() {
        let absolute_path_str = "/an/absolute/path.txt";
        let bundle_content = format!(
            "{}\n\
            {}{}\n\
            {}\n\
            Content",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, absolute_path_str, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::AbsolutePathNotAllowed {
                line_number: 2,
                path: absolute_path_str.to_string(),
            },
        );
    }

    #[test]
    fn test_error_duplicate_path() {
        let bundle_content = format!(
            "{}\n\
            {}file.txt\n\
            {}\n\
            Content1\n\
            {}\n\
            {}file.txt\n\
            {}\n\
            Content2",
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR,
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::DuplicatePath {
                line_number: 6,
                path: "file.txt".to_string(),
            },
        );
    }

    #[test]
    fn test_error_premature_eof_after_first_separator() {
        let bundle_content = FILE_HEADER_SEPARATOR;
        let temp_file = create_temp_bundle_file(bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::PrematureEOFBeforePathLine { line_number: 1 },
        );
    }

    #[test]
    fn test_error_premature_eof_after_file_prefix() {
        let bundle_content = format!("{}\n{}", FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX);
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderPathLineMissingNewline {
                line_number: 2,
                path_line: "".to_string(),
            },
        );
    }

    #[test]
    fn test_error_premature_eof_after_path_line() {
        let bundle_content = format!("{}\n{}path.txt", FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX);
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert_specific_error(
            &result,
            BundleValidationError::MalformedHeaderPathLineMissingNewline {
                line_number: 2,
                path_line: "path.txt".to_string(),
            },
        );
    }

    #[test]
    fn test_error_unexpected_content_after_last_entry() {
        let bundle_content = format!(
            "{}\n\
            {}file.txt\n\
            {}\n\
            Content\n\
            Some trailing garbage text.",
            FILE_HEADER_SEPARATOR, FILE_PATH_PREFIX, FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());
        assert!(result.is_ok(), "Expected Ok, got {:?}", result);
        let entries = result.unwrap();
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].path, PathBuf::from("file.txt"));
        assert_eq!(entries[0].content, "Content\nSome trailing garbage text.");
    }

    #[test]
    fn test_multiple_errors_reported() {
        let bundle_content = format!(
            "Leading garbage.\n\
            {}\n\
            {}/abs/path.txt\n\
            {}\n\
            Content1\n\
            {}\n\
            {}\n\
            {}\n\
            Content2\n\
            Trailing garbage.",
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR,
            FILE_HEADER_SEPARATOR,
            FILE_PATH_PREFIX,
            FILE_HEADER_SEPARATOR
        );
        let temp_file = create_temp_bundle_file(&bundle_content);
        let result = parse_bundle(temp_file.path());

        assert!(result.is_err());
        if let Err(err) = result {
            if let Some(bundle_parse_error) = err.downcast_ref::<BundleParseError>() {
                assert_eq!(
                    bundle_parse_error.errors.len(),
                    2,
                    "Expected 2 errors, got {}. Errors: {:?}",
                    bundle_parse_error.errors.len(),
                    bundle_parse_error.errors
                );

                assert!(
                    !bundle_parse_error.errors.contains(
                        &BundleValidationError::ContentBeforeFirstHeader {
                            line_number: 1,
                            content_excerpt: "Leading garbage.".to_string()
                        }
                    ),
                    "ContentBeforeFirstHeader should now be a warning, not an error."
                );

                assert!(bundle_parse_error.errors.contains(
                    &BundleValidationError::AbsolutePathNotAllowed {
                        line_number: 3,
                        path: "/abs/path.txt".to_string()
                    }
                ));
                assert!(
                    bundle_parse_error
                        .errors
                        .contains(&BundleValidationError::EmptyPath { line_number: 7 })
                );
            } else {
                panic!("Error is not a BundleParseError: {:?}", err);
            }
        } else {
            panic!("Expected an error, but got Ok. Result: {:?}", result);
        }
    }
}



================================================
File: tests/integration_tests.rs
================================================
use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions
use std::fs;
use std::io::Write;
use std::process::Command; // Run programs
use tempfile::NamedTempFile;
use tempfile::TempDir;

// Helper function to create a temporary bundle file with given content
fn create_temp_bundle_file(content: &str) -> NamedTempFile {
    let mut file = NamedTempFile::new().expect("Failed to create temp bundle file");
    // Use write! to avoid adding an extra newline to the content string itself
    // The parser and bundler should handle content with or without trailing newlines correctly,
    // as a user might create them.
    write!(file, "{}", content).expect("Failed to write to temp bundle file");
    file
}

#[test]
fn test_valid_bundle_simple_structure() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: file1.txt\n================================================\nHello from file1\n================================================\nFile: file2.txt\n================================================\nContent of file2\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 2 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file1_path = output_dir.path().join("file1.txt");
    let file2_path = output_dir.path().join("file2.txt");

    assert!(file1_path.exists());
    assert_eq!(fs::read_to_string(file1_path)?, "Hello from file1\n");

    assert!(file2_path.exists());
    assert_eq!(fs::read_to_string(file2_path)?, "Content of file2\n");

    Ok(())
}

#[test]
fn test_valid_bundle_nested_structure() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: dir1/file1.txt\n================================================\nNested content\n================================================\nFile: dir1/dir2/file2.txt\n================================================\nDeeply nested\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 2 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file1_path = output_dir.path().join("dir1/file1.txt");
    let file2_path = output_dir.path().join("dir1/dir2/file2.txt");

    assert!(file1_path.exists());
    assert_eq!(fs::read_to_string(file1_path)?, "Nested content\n");

    assert!(file2_path.exists());
    assert_eq!(fs::read_to_string(file2_path)?, "Deeply nested\n");

    Ok(())
}

#[test]
fn test_malformed_bundle_file() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: file1.txt\nThis is not a valid header\nContent\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert().failure().stderr(
        predicate::str::contains("Bundle parsing failed")
            .and(predicate::str::contains("Malformed file header")),
    );

    // Ensure no files were created
    assert!(fs::read_dir(output_dir.path())?.next().is_none());

    Ok(())
}

#[test]
fn test_output_file_collision() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: existing_file.txt\n================================================\nSome content\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    // Create a conflicting file
    let conflicting_file_path = output_dir.path().join("existing_file.txt");
    fs::write(&conflicting_file_path, "Original content")?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert().failure().stderr(
        predicate::str::contains("Output path collision detected").and(predicate::str::contains(
            conflicting_file_path.to_str().unwrap(),
        )),
    );

    // Ensure the original file was not overwritten
    assert_eq!(
        fs::read_to_string(conflicting_file_path)?,
        "Original content"
    );

    Ok(())
}

#[test]
fn test_empty_bundle_file() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_file = create_temp_bundle_file("");
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert()
        .success() // Empty bundle is not an error, just nothing to do
        .stdout(predicate::str::contains(format!(
            "Bundle file '{}' is empty or contains no valid entries. Nothing to sprout.",
            bundle_file.path().display()
        )));

    // Ensure no files were created
    assert!(fs::read_dir(output_dir.path())?.next().is_none());
    Ok(())
}

#[test]
fn test_output_to_current_directory_default() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: default_dir_file.txt\n================================================\nDefault dir test\n";
    let bundle_file = create_temp_bundle_file(bundle_content);

    // Create a temporary directory to act as the "current directory" for the test
    let current_dir_scope = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.current_dir(current_dir_scope.path()) // Set current directory for the command
        .arg(bundle_file.path()); // No output dir specified, should default to current_dir_scope

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 1 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            "." // Output path should be displayed as "."
        )));

    let file_path = current_dir_scope.path().join("default_dir_file.txt");
    assert!(file_path.exists());
    assert_eq!(fs::read_to_string(file_path)?, "Default dir test\n");

    Ok(())
}

#[test]
fn test_output_to_specified_directory_via_positional_arg() -> Result<(), Box<dyn std::error::Error>>
{
    let bundle_content = "================================================\nFile: specified_pos_file.txt\n================================================\nSpecified dir test - positional\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 1 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file_path = output_dir.path().join("specified_pos_file.txt");
    assert!(file_path.exists());
    assert_eq!(
        fs::read_to_string(file_path)?,
        "Specified dir test - positional\n"
    );

    Ok(())
}

#[test]
fn test_output_to_specified_directory_via_o_flag() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: specified_flag_file.txt\n================================================\nSpecified dir test - flag\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()) // Can also use -i for input
        .arg("-o")
        .arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 1 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file_path = output_dir.path().join("specified_flag_file.txt");
    assert!(file_path.exists());
    assert_eq!(
        fs::read_to_string(file_path)?,
        "Specified dir test - flag\n"
    );

    Ok(())
}

#[test]
fn test_input_via_i_flag() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: input_flag_test.txt\n================================================\nInput via -i flag\n";
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg("-i")
        .arg(bundle_file.path())
        .arg("-o")
        .arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 1 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file_path = output_dir.path().join("input_flag_test.txt");
    assert!(file_path.exists());
    assert_eq!(fs::read_to_string(file_path)?, "Input via -i flag\n");

    Ok(())
}

#[test]
fn test_missing_input_bundle() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("sprout")?;
    // No input argument provided
    cmd.assert().failure().stderr(
        predicate::str::contains("error: the following required arguments were not provided:")
            .and(predicate::str::contains("<BUNDLE_FILE_PATH>")),
    );
    Ok(())
}

#[test]
fn test_bundle_with_empty_file_content() -> Result<(), Box<dyn std::error::Error>> {
    let bundle_content = "================================================\nFile: empty_file.txt\n================================================\n"; // Empty content
    let bundle_file = create_temp_bundle_file(bundle_content);
    let output_dir = TempDir::new()?;

    let mut cmd = Command::cargo_bin("sprout")?;
    cmd.arg(bundle_file.path()).arg(output_dir.path());

    cmd.assert()
        .success()
        .stdout(predicate::str::contains(format!(
            "Successfully sprouted 1 file(s) from '{}' to '{}'.",
            bundle_file.path().display(),
            output_dir.path().display()
        )));

    let file_path = output_dir.path().join("empty_file.txt");
    assert!(file_path.exists());
    assert_eq!(fs::read_to_string(file_path)?, ""); // Content should be empty string

    Ok(())
}




================================================
File: .github/workflows/ci.yml
================================================
name: Rust CI

permissions:
  contents: read # For actions/checkout
  security-events: write # For github/codeql-action/upload-sarif (if used, not in this version but good to have)
  actions: read # For actions/cache
  # Coveralls might need issues:write or similar if it posts comments, but usually just needs a token.
  # For coverallsapp/github-action, it primarily needs to read code and push data to Coveralls.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build_and_test:
    name: Test on Rust ${{ matrix.rust-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust-version: [stable] # You can add more versions like 'beta', 'nightly', or specific versions '1.70.0'

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit # Configure as needed, 'audit' is a good start

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2 # Or 0 for full history if needed by any tools

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable # Using dtolnay's action, very common
        with:
          toolchain: ${{ matrix.rust-version }}
          components: clippy, rustfmt # Install clippy and rustfmt along with the toolchain

      - name: Cache Cargo dependencies
        uses: actions/cache@13aacd865c20de90d75decf172eb50a30f6a4f89 # v4.0.0
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/            # Cache the target directory to speed up subsequent builds
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install additional Rust tools
        run: |
          cargo install cargo-audit
          cargo install cargo-tarpaulin --version 0.32.7

      - name: Run security audit
        run: cargo audit

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Lint code
        # --all-targets: Check library, binaries, tests, examples, etc.
        # -D warnings: Treat all warnings as errors, failing the build
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Run tests
        run: cargo test --all-features --verbose

      - name: Generate code coverage (Tarpaulin)
        # Llvm engine is generally recommended.
        # Outputting Cobertura XML as it's a common format for Coveralls.
        # --all-features: Ensure all conditional code is included if tested.
        # --workspace: If you have a workspace, to cover all crates.
        # --timeout: Increase if tests are long-running.
        # --skip-clean: Avoids cleaning the target dir if not needed, might speed up a bit with caching.
        run: |
          cargo tarpaulin --verbose --all-features --workspace --engine Llvm --out Xml --output-dir target/tarpaulin
          # Tarpaulin by default creates cobertura.xml in the output directory

      - name: Upload coverage to Coveralls
        uses: coverallsapp/github-action@v2.5.0 # v2.5.0 as of May 2024
        if: matrix.rust-version == 'stable' # Only upload from one Rust version
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Provided by GitHub Actions
          file: target/tarpaulin/cobertura.xml # Path to the Cobertura report
          # service_name: github # Usually auto-detected
          # coveralls_endpoint: https://coveralls.io # Default, change if using Coveralls Enterprise
          # You might need to set COVERALLS_REPO_TOKEN as an environment variable if the action requires it
          # and github-token is not sufficient for private repos or specific setups.
          # env:
          #   COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
          # However, coverallsapp/github-action v2 usually prefers GITHUB_TOKEN for public repos.
          # For private repos, COVERALLS_REPO_TOKEN is typically required by Coveralls.
          # The action's documentation is the best source for token requirements.



