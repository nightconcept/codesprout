Directory structure:
└── codesprout/
    ├── docs/
    │   ├── PRD.md
    │   └── TASKS.md
    ├── src/
    │   └── main.rs
    ├── .cursor/
    ├── .github/
    │   └── workflows/
    │       └── ci.yml
    └── .roo/

================================================
File: docs/PRD.md
================================================
# codesprout - Product Requirements Document (Prototype)

## 1. Introduction

- **Project Idea:** `codesprout` is a project to develop a command-line interface (CLI) utility named `sprout`. The `sprout` tool's primary function is to parse a single, consolidated text file (referred to as a "bundle file," formatted like the provided `digest.txt` example) and "sprout" its contents into an organized directory structure with corresponding files.
- **Problem/Need:** Developers, educators, and technical writers often need to share or archive sets of code files or project snippets. Traditional methods like zip archives are not always convenient, especially for embedding into documents, wikis, or systems that primarily accept plain text. A single-file representation simplifies copy-pasting, sharing in restrictive environments, and creating self-contained examples.
- **Prototype Goal:** To build a functional `sprout` CLI in Rust that can reliably parse a `digest.txt`-style bundle file, validate its format, and recreate the described directory structure and files in a specified output location. The prototype must include clear error reporting for format issues and abort on any potential file collisions in the output directory.

## 2. Core Features / User Stories

- **Feature 1: Sprout from Bundle**
    - Description: The `sprout` CLI will read a specified bundle file (formatted like `digest.txt`), parse its content to identify individual files and their target paths, and then create these files and any necessary parent directories in the designated output location.
    - User Action(s): The user executes the `sprout` command, providing the path to the bundle file and an optional output directory.
    - Outcome(s):
        - If the bundle file is valid and no file collisions are detected in the output path, the specified directory structure and files are created as per the bundle file's content. A success message is displayed.
        - If the bundle file contains format errors, all errors are reported to the user, and no file system modifications are made.
        - If creating any file would overwrite an existing file or directory in the output path, the operation is aborted before any files are written, and an error message is displayed.
    - Command: `sprout`
    - Key Inputs:
        - Bundle File Path (required): Provided as a positional argument or via `-i <path>` / `--input <path>`.
        - Output Directory Path (optional): Provided as a positional argument or via `-o <path>` / `--output <path>`. Defaults to the current working directory.
    - Expected Output:
        - Console messages indicating files being processed (optional, perhaps under a verbose flag in the future, but basic status for prototype).
        - Clear success message upon completion.
        - Detailed error messages if bundle file validation fails or if file collisions are detected.
        - The recreated files and directories in the specified output location.

## 3. Technical Specifications

- **Primary Language(s):** Rust (latest stable version available at the time of development, e.g., 1.7X.X).
- **Key Frameworks/Libraries:**
    - `clap`: For parsing CLI arguments.
    - `anyhow`: (Recommended) For application-level error handling and reporting.
- **Database (if any):** None for this prototype.
- **Key APIs/Integrations (if any):** None.
- **Deployment Target (if applicable for prototype):** Local native executable for common desktop platforms (Linux, macOS, Windows).
- **High-Level Architectural Approach:**
    - A CLI application built in Rust.
    - Core logic will be separated into modules:
        - One module for parsing the `digest.txt`-style bundle file.
        - One module for handling file system operations (directory creation, file writing, collision detection).
        - Error handling will be centralized, potentially using custom error types or `anyhow` for context.
    - The process flow will be: 1. Parse arguments. 2. Read and fully validate the input bundle file. 3. Check for output collisions. 4. If all checks pass, create directories and files.
- **Critical Technical Decisions/Constraints:**
    - The input bundle file format is strictly the `digest.txt` style (multi-file concatenation with `================================================\nFile: path/to/file.ext\n================================================\n...content...` delimiters).
    - The `sprout` tool will perform a full analysis of the input bundle file for any format errors before attempting any file system modifications. If errors are found, they will be reported, and the tool will exit.
    - The tool will check for potential file/directory collisions in the target output directory before writing any files. If any collision is detected, the operation will be aborted with an error message, and no files will be written.

## 4. Project Structure (Optional)

A standard Rust binary (application) project structure will be used, generated initially by `cargo new sprout --bin`.

```
/codesprout_project_root
  ├── .git/
  ├── .github/              # For GitHub Actions, issue templates, etc.
  ├── docs/
  │   ├── PRD.md            # This document
  │   └── TASKS.md          # Task list
  ├── src/
  │   ├── main.rs           # CLI entry point, argument parsing (clap), main logic flow
  │   ├── parser.rs         # Module for parsing the bundle file
  │   ├── bundler.rs        # Module for file/directory creation and output logic (renamed from sprouter for clarity)
  │   └── error.rs          # (Optional) Module for custom error types if not solely relying on anyhow
  ├── Cargo.toml            # Rust project manifest, dependencies
  ├── Cargo.lock            # Generated lockfile
  ├── README.md             # Project README
  └── target/               # Build artifacts (ignored by git)
```

- `src/`: Contains all Rust source code.
    - `main.rs`: Handles CLI argument parsing using `clap` and orchestrates the overall process.
    - `parser.rs`: Responsible for reading and validating the `digest.txt`-style bundle file format.
    - `bundler.rs`: Handles the creation of directories and files based on the parsed bundle, including collision checks.
- `docs/`: Contains project documentation.
- `Cargo.toml`: Defines project metadata, dependencies (like `clap`, `anyhow`), and profiles (e.g., for release optimization).

## 5. File Descriptions (If applicable)

- **Input Bundle File (e.g., `my_bundle.txt`, `project.digest`)**:
    - Purpose: A single text file containing the content of multiple source files or text-based project structures, along with their intended relative paths.
    - Format: Plain text. Each embedded file is demarcated by a header `================================================\nFile: path/to/file.ext\n================================================\n` followed by its content. The `path/to/file.ext` specifies the relative path where the file should be created in the output directory.
    - Key Contents: A sequence of file path specifications and their corresponding multi-line text content.

## 6. Future Considerations / Out of Scope (for this prototype)

- **Out of Scope for Prototype:**
    - **Reverse Operation ("Bundling"):** Creating a bundle file from an existing directory structure.
    - **Advanced Overwrite Options:** No `--force` flag or interactive prompts to overwrite files. The prototype will only abort on collision.
    - **Configuration File:** No external configuration for `sprout` (e.g., to customize delimiters or behavior).
    - **Ignore Patterns:** No functionality to ignore specific files or patterns during a (future) bundling operation.
    - **Complex Format Validation Beyond Basic Structure:** While basic structural validation (presence of delimiters, parsable paths) is in scope, deep semantic analysis of the content within files is not.
    - **Watching files or live updates.**
- **Potential Future Enhancements (Post-Prototype):**
    - Implement the reverse "bundling" operation.
    - Add file overwrite protection options (`--force`, skip, prompt).
    - Introduce a configuration file for `sprout`.
    - Support for ignore patterns (like `.gitignore`) during bundling.
    - Stricter validation options for bundle files.
    - Support for different bundle formats or custom delimiters via configuration.

## 7. Project-Specific Coding Rules (Optional)

- **Language Version:** Rust (latest stable version at the time of development).
- **Formatting:** `rustfmt` is mandatory. Code should be formatted using `cargo fmt` before committing.
- **Linting:** `clippy` is mandatory. Code should pass `cargo clippy --all-targets -- -D warnings` (fail on warnings).
- **Error Handling:**
    - Use Rust's standard `Result<T, E>` for all functions that can produce an error.
    - Utilize the `?` operator for concise error propagation.
    - Employ the `anyhow` crate for creating and managing application-level errors, providing context, and simplifying error returns from `main()`.
- **Dependencies (`Cargo.toml`):**
    - `clap` will be used for CLI argument parsing.
    - `anyhow` will be used for error handling.
    - Other external crate dependencies should be minimized and require justification for inclusion in the prototype.
- **Testing:**
    - Unit tests for the `parser.rs` module to ensure correct parsing of various valid and invalid bundle file scenarios.
    - Unit tests for the `bundler.rs` module to ensure correct file/directory creation, path handling, and collision detection logic.
    - Integration-style tests (CLI tests) to verify the overall behavior of `sprout` with sample bundle files and output directory states.
- **Naming Conventions:** Adhere to standard Rust naming conventions:
    - `snake_case` for functions, methods, variables, and modules.
    - `PascalCase` (or `CamelCase`) for types, structs, enums, and traits.
    - `UPPER_SNAKE_CASE` for constants.
- **Binary Size:** Strive for a reasonably small binary size for the release executable by configuring the release profile in `Cargo.toml` (e.g., `opt-level = "z"`, `lto = true`, `codegen-units = 1`, `panic = "abort"`, `strip = true`) and/or using `strip` utility post-compilation.
- **Comments:** Write clear comments for complex logic, public API functions, and any non-obvious decisions. Doc comments (`///`) for public items are encouraged.
- **Modularity:** Keep functions small and focused. Modules should have clear responsibilities.



================================================
File: docs/TASKS.md
================================================
# codesprout - Task List

## Milestone 0: Development Environment & Workflow Setup

**Goal:** Establish a consistent Rust development environment using `mise` and define commands/scripts for essential development tasks such as formatting, linting, building, and testing the `sprout` CLI.

- [x] **Task 0.1: Setup `mise` for Rust Version Management**
  - [x] Create a `mise.toml` file in the project root.
  - [x] Specify the Rust version to be used for the project (e.g., `rust = "latest"` or a specific version like `rust = "1.87"` to align with PRD).
  - [x] Verification: After navigating to the project directory in a new terminal, `mise current rust` (or `mise which rustc`) shows the correct Rust compiler path and version as specified in `.mise.toml`. Running `rustc --version` confirms the active version.

- [x] **Task 0.2: Define Code Formatting Task & Integration**
  - [x] Document the command for checking formatting: `cargo fmt --all --check`.
  - [x] Document the command for applying formatting: `cargo fmt --all`.
  - [ ] (Optional) Consider integrating `cargo fmt --all --check` into a pre-commit hook or CI step later.
    - [x] Verification: `cargo fmt --all --check` passes on a cleanly formatted codebase. `cargo fmt --all` correctly formats any misformatted Rust files.
- [x] **Task 0.3: Define Code Linting Task & Integration**
  - [x] Document the command for linting: `cargo clippy --all-targets -- -D warnings` (treat all warnings as errors).
  - [ ] (Optional) Consider integrating this lint check into a pre-commit hook or CI step later.
  - [x] Verification: `cargo clippy --all-targets -- -D warnings` passes on a lint-free codebase.
- [ ] **Task 0.4: Define Building Tasks**
  - [x] Document command for debug builds: `cargo build`.
  - [ ] Document command for optimized release builds: `cargo build --release`.
  - [x] Note: `Cargo.toml` should be configured with release profile optimizations as per PRD (e.g., `opt-level = "z"`, `lto = true`, `panic = "abort"`, `strip = true`).
  - [x] Verification: `cargo build` successfully compiles the project. `cargo build --release` successfully compiles the project and produces an optimized binary.
- [x] **Task 0.5: Define Testing Task**  
    - [x] Document command for running all tests: `cargo test`.
    - [x] Document command for running tests with more output: `cargo test -- --nocapture` (if needed for debugging).
    - [x] Verification: `cargo test` runs all available tests and reports pass/fail status (initially, this might be an empty test suite or auto-generated tests).

## Milestone 1: Project Initialization & CLI Argument Parsing

**Goal:** Initialize the Rust project structure for `sprout` (if not fully covered by Milestone 0 tasks related to `cargo new`), implement robust command-line argument parsing using `clap`, and set up the basic application structure to handle the main processing flow.

- [x] **Task 1.1: Complete Rust Project Initialization**
    
    - [x] Run `cargo new sprout --bin` (if not done as part of `mise` setup or if a fresh start is preferred).
    - [x] Ensure `Cargo.toml` is correctly configured:
        - Set `name = "sprout"` (as the binary will be `sprout`), `description = "A CLI tool to sprout files from a bundle."`, `authors = ["Your Name <you@example.com>"]`, `edition = "2024"`, `version = "0.1.0"`.
        - Add `clap` as a dependency with the "derive" feature (e.g., `clap = { version = "4.x", features = ["derive"] }`).
        - Add `anyhow` as a dependency (e.g., `anyhow = "1.x"`).
    - [x] Verification: Project compiles successfully (`cargo build`). `Cargo.toml` reflects the specified settings and dependencies. `sprout --version` (once version is integrated with `clap`'s `App::version`) works.
- [x] **Task 1.2: Implement CLI Argument Parsing with `clap`**
    
    - [x] In `src/main.rs`, define a struct (e.g., `CliArgs`) using `clap::Parser` to manage command-line arguments.
    - [x] Implement parsing for:
        - `bundle_file_path` (positional, `PathBuf`, required unless `-i` is used).
        - `output_directory_path` (positional, `PathBuf`, optional, defaults to current directory unless `-o` is used).
        - `-i, --input <PATH>`: Optional flag for bundle file path (`Option<PathBuf>`).
        - `-o, --output <PATH>`: Optional flag for output directory path (`Option<PathBuf>`).
    - [x] Logic to determine effective input and output paths (handling defaults and overrides).
    - [x] Ensure input path is effectively mandatory.
    - [x] In `main()`, parse the arguments using `CliArgs::parse()`.
    - [x] Verification:
        - `sprout --help` displays correctly formatted help message with all arguments and options.
        - `sprout valid_bundle.txt` correctly identifies `valid_bundle.txt` as input and uses `.` as default output.
        - `sprout -i valid_bundle.txt -o ./my_output` correctly parses input and output paths.
        - `sprout ./my_output_dir` (assuming `my_output_dir` is not the bundle file) is handled by clap for positional args.
        - `sprout` (with no input arguments) shows an error message from `clap` indicating missing required input.
- [ ] **Task 1.3: Establish Main Application Logic Flow & Error Handling**
    
    - [ ] In `src/main.rs`, ensure `main` function returns `anyhow::Result<()>`.
    - [ ] Define the high-level steps based on parsed arguments:
        1. Resolve final input and output paths.
        2. (Stub) Call `parser::process_bundle_file(input_path)`.
        3. (Stub) If parsing/validation successful, call `bundler::create_files(parsed_data, output_path)`.
    - [ ] Implement basic stubs for these functions in their respective (future) modules (`parser.rs`, `bundler.rs`).
    - [ ] Ensure `main` propagates errors from these calls using `?`.
    - [ ] Verification: The `sprout` command runs, prints placeholder messages for each stubbed step based on parsed arguments, and exits gracefully (or with a placeholder error from a stub).

## Milestone 2: Bundle File Parsing and Validation

**Goal:** Implement the complete logic for reading, parsing, and validating the `digest.txt`-style bundle file. The tool should be able to identify all format errors in the bundle file before any file system operations are attempted.

- [ ] **Task 2.1: Develop Bundle File Parser (`src/parser.rs`)**
    
    - [ ] Create the `src/parser.rs` module.
    - [ ] Define a public function, e.g., `parse_bundle(bundle_path: &Path) -> anyhow::Result<Vec<ParsedEntry>>`.
    - [ ] Implement logic to read the content of the bundle file.
    - [ ] Implement parsing logic to iterate through the file content, recognizing the `================================================\nFile: path/to/file.ext\n================================================\n...content...` structure.
    - [ ] Extract the relative file path (`String` or `PathBuf`) and the multi-line content (`String`) for each entry.
    - [ ] Store the parsed data in a struct, e.g., `pub struct ParsedEntry { pub path: PathBuf, pub content: String }`.
    - [ ] Verification: Unit tests for the `parser::parse_bundle` function covering:
        - Empty bundle file (should return empty Vec or appropriate error).
        - Bundle file with one entry.
        - Bundle file with multiple entries.
        - Entries with empty content.
        - Entries with complex multi-line content.
        - Correct path extraction (including paths with subdirectories).
- [ ] **Task 2.2: Implement Bundle File Format Validation**
    
    - [ ] Within `src/parser.rs`, enhance the parsing or add a distinct validation step for the parsed entries and the overall bundle structure. This validation should occur before returning successfully from `parse_bundle`.
    - [ ] Validation checks should include:
        - Each `File:` header line must be properly formed and contain a non-empty, valid relative path.
        - No duplicate paths within the bundle.
        - Consider edge cases: premature EOF, missing headers, content before the first header (should it be ignored or an error?).
    - [ ] The validation should collect _all_ format errors found in the bundle and return them as a single `anyhow::Error` (possibly by formatting a list of specific error details).
    - [ ] In `src/main.rs`, call `parse_bundle`. If it returns `Err`, print the error (which should now include all validation issues) and exit.
    - [ ] Verification:
        - Update unit tests for `parser::parse_bundle` to cover various invalid bundle file scenarios (e.g., malformed `File:` line, duplicate paths, EOF within a file block).
        - Test the `sprout` CLI with sample malformed bundle files; ensure all relevant errors are reported clearly and the program exits without attempting to write files.

## Milestone 3: File System Operations, Collision Detection, and Final Integration

**Goal:** Implement the logic to create the directory structure and files as specified in the parsed bundle. This includes robust collision detection in the output directory. This milestone will result in a fully functional `sprout` CLI for its core purpose.

- [ ] **Task 3.1: Implement Output Path Collision Detection (`src/bundler.rs`)**
    
    - [ ] Create the `src/bundler.rs` module.
    - [ ] Implement a function, e.g., `check_for_collisions(entries: &[ParsedEntry], output_dir: &Path) -> anyhow::Result<()>`.
    - [ ] For each `ParsedEntry` in the list:
        - Construct the full target path by joining `output_dir` and `entry.path`.
        - Check if this full target path already exists using `std::path::Path::exists()`.
    - [ ] If any path collision is detected, this function should return an `anyhow::Error` detailing all collisions found.
    - [ ] In `src/main.rs`, call this collision check function after successful bundle parsing. If it returns `Err`, print the error and exit.
    - [ ] Verification:
        - Unit tests for `bundler::check_for_collisions` with scenarios: no collisions, one collision, multiple collisions, collision with a file where a directory is needed, collision with a directory where a file is needed.
        - CLI Test: `sprout` aborts with an informative error if a target file path already exists.
        - CLI Test: `sprout` aborts if a parent directory to be created (e.g., `new_dir/`) conflicts with an existing file named `new_dir`.
- [ ] **Task 3.2: Implement Directory and File Creation (`src/bundler.rs`)**
    
    - [ ] Implement a function, e.g., `create_files_from_bundle(entries: &[ParsedEntry], output_dir: &Path) -> anyhow::Result<()>`.
    - [ ] This function is called only if bundle parsing and collision checks pass.
    - [ ] For each `ParsedEntry`:
        - Resolve the full absolute path for the new file.
        - Ensure its parent directory exists using `std::fs::create_dir_all(parent_path)`.
        - Write the `entry.content` to the file path using `std::fs::write`.
    - [ ] Handle potential I/O errors during directory/file creation gracefully, returning an `anyhow::Error`.
    - [ ] Verification:
        - Unit tests for `bundler::create_files_from_bundle` to verify:
            - Creation of a single file in the output directory.
            - Creation of multiple files.
            - Creation of files within newly created nested subdirectories.
            - Correct writing of file content.
        - (Covered by integration tests in next task mostly)
- [ ] **Task 3.3: Final Integration, User Feedback, and Testing**
    
    - [ ] Integrate all components in `src/main.rs`: CLI parsing (`clap`), bundle file reading/validation (`parser.rs`), collision detection, and file/directory creation (`bundler.rs`).
    - [ ] Implement clear success messages (e.g., "Successfully sprouted N files to <output_directory>.").
    - [ ] Ensure all error paths (bundle format errors, I/O errors, collision errors) provide user-friendly messages propagated by `anyhow`.
    - [ ] Write integration tests for the `sprout` CLI (e.g., using a test runner or simple shell scripts that invoke the compiled binary):
        - Test with a valid bundle file creating a simple structure.
        - Test with a valid bundle file creating a nested structure.
        - Test failure with a malformed bundle file (ensure all errors are printed).
        - Test failure due to output file collision (ensure specific collision is reported).
        - Test with empty bundle file.
        - Test output to current directory (default) and to a specified directory.
    - [ ] Verification: The `sprout` command works end-to-end for valid scenarios and fails gracefully with correct, comprehensive error messages for all defined error conditions. Code coverage for core logic (parsing, bundling) is reasonable.

## Additional Tasks / Backlog

(Items from the PRD's "Future Considerations" that are out of scope for this initial prototype but good to keep in mind for future development)

- [ ] Implement Reverse Operation ("Bundling" a directory into a `digest.txt` style file).
- [ ] Add file overwrite protection options (`--force`, skip, prompt).
- [ ] Introduce a configuration file for `sprout` (e.g., custom delimiters, default output dir).
- [ ] Add more comprehensive test cases for file system edge cases (permissions, symlinks, etc.).
- [ ] Refine and add more detailed verbose logging options (e.g., using `log` and `env_logger` crates).
- [ ] Research and implement packaging/distribution methods for the Rust binary (e.g., `cargo-dist`, GitHub Releases assets, AUR, Homebrew).
- [ ] Performance benchmarking and optimization for very large bundle files or a high number of files.


================================================
File: src/main.rs
================================================
use clap::Parser;
use std::path::PathBuf;

/// sprout - A CLI tool to sprout files from a bundle.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None, infer_long_args = true)]
struct CliArgs {
    /// Path to the bundle file (positional).
    /// Required unless -i/--input is used.
    #[arg(name = "BUNDLE_FILE_PATH", required_unless_present = "input")]
    bundle_file_path: Option<PathBuf>,

    /// Output directory path (positional).
    /// Defaults to the current directory if not specified and -o/--output is not used.
    #[arg(name = "OUTPUT_DIRECTORY_PATH", default_value = ".")]
    output_directory_path: PathBuf,

    /// Specify bundle file path via flag (alternative to positional BUNDLE_FILE_PATH).
    #[arg(short, long, value_name = "PATH", conflicts_with = "BUNDLE_FILE_PATH")]
    input: Option<PathBuf>,

    /// Specify output directory path via flag (overrides positional OUTPUT_DIRECTORY_PATH).
    #[arg(short, long, value_name = "PATH")]
    output: Option<PathBuf>,
}

fn main() -> anyhow::Result<()> {
    let args = CliArgs::parse();

    // Determine effective input path.
    // Clap ensures that either `bundle_file_path` or `input` is Some, but not both,
    // and that at least one of them is provided.
    let bundle_path = match (args.bundle_file_path, args.input) {
        (Some(p), None) => p,
        (None, Some(i)) => i,
        // The following cases should be prevented by clap's validation:
        // (None, None) => Error: missing required input (handled by `required_unless_present`)
        // (Some(_), Some(_)) => Error: conflicting arguments (handled by `conflicts_with`)
        _ => unreachable!("Clap should ensure one input source is exclusively provided and valid."),
    };

    // Determine effective output path.
    // If -o/--output is provided, it takes precedence.
    // Otherwise, use the positional `output_directory_path` (which defaults to ".").
    let final_output_path = if let Some(output_flag_path) = args.output {
        output_flag_path
    } else {
        args.output_directory_path
    };

    println!("Effective bundle file path: {:?}", bundle_path);
    println!("Effective output directory path: {:?}", final_output_path);

    // Placeholder for further processing based on Task 1.3
    // 1. Resolve final input and output paths (done above)
    // 2. (Stub) Call parser::process_bundle_file(&bundle_path)
    // 3. (Stub) If parsing/validation successful, call bundler::create_files(parsed_data, &final_output_path)

    Ok(())
}




================================================
File: .github/workflows/ci.yml
================================================
name: Rust CI

permissions:
  contents: read # For actions/checkout
  security-events: write # For github/codeql-action/upload-sarif (if used, not in this version but good to have)
  actions: read # For actions/cache
  # Coveralls might need issues:write or similar if it posts comments, but usually just needs a token.
  # For coverallsapp/github-action, it primarily needs to read code and push data to Coveralls.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build_and_test:
    name: Test on Rust ${{ matrix.rust-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust-version: [stable] # You can add more versions like 'beta', 'nightly', or specific versions '1.70.0'

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
        with:
          egress-policy: audit # Configure as needed, 'audit' is a good start

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2 # Or 0 for full history if needed by any tools

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable # Using dtolnay's action, very common
        with:
          toolchain: ${{ matrix.rust-version }}
          components: clippy, rustfmt # Install clippy and rustfmt along with the toolchain

      - name: Cache Cargo dependencies
        uses: actions/cache@13aacd865c20de90d75decf172eb50a30f6a4f89 # v4.0.0
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/            # Cache the target directory to speed up subsequent builds
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install additional Rust tools
        run: |
          cargo install cargo-audit
          cargo install cargo-tarpaulin --version 0.32.7

      - name: Run security audit
        run: cargo audit

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Lint code
        # --all-targets: Check library, binaries, tests, examples, etc.
        # -D warnings: Treat all warnings as errors, failing the build
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Run tests
        run: cargo test --all-features --verbose

      - name: Generate code coverage (Tarpaulin)
        # Llvm engine is generally recommended.
        # Outputting Cobertura XML as it's a common format for Coveralls.
        # --all-features: Ensure all conditional code is included if tested.
        # --workspace: If you have a workspace, to cover all crates.
        # --timeout: Increase if tests are long-running.
        # --skip-clean: Avoids cleaning the target dir if not needed, might speed up a bit with caching.
        run: |
          cargo tarpaulin --verbose --all-features --workspace --engine Llvm --out Xml --output-dir target/tarpaulin
          # Tarpaulin by default creates cobertura.xml in the output directory

      - name: Upload coverage to Coveralls
        uses: coverallsapp/github-action@v2.5.0 # v2.5.0 as of May 2024
        if: matrix.rust-version == 'stable' # Only upload from one Rust version
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Provided by GitHub Actions
          file: target/tarpaulin/cobertura.xml # Path to the Cobertura report
          # service_name: github # Usually auto-detected
          # coveralls_endpoint: https://coveralls.io # Default, change if using Coveralls Enterprise
          # You might need to set COVERALLS_REPO_TOKEN as an environment variable if the action requires it
          # and github-token is not sufficient for private repos or specific setups.
          # env:
          #   COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
          # However, coverallsapp/github-action v2 usually prefers GITHUB_TOKEN for public repos.
          # For private repos, COVERALLS_REPO_TOKEN is typically required by Coveralls.
          # The action's documentation is the best source for token requirements.



